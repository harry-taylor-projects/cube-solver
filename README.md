# Cube Solver

An efficient Rubik's cube solver inspired by [Kociemba's algorithm](https://kociemba.org/cube.htm).

### Overview

The algorithm is made up of two phases: Domino reduction (DR) and solving using the reduced move set.
The first phase aims to solve the corner orientation (CO), edge orientation (EO) and equator edge locations (EqL).
The second phase aims to solve the corner permutation (CP), edge permutation (EP) and the equator edge 
permutation (EqP).

Splitting the search into two phases allows the program to find solutions in a reasonable time without increasing the 
move count of the solution very much. For example: Searching 11 moves deep in the first phase and then 15 moves deep in 
the second phase (roughly 18<sup>11</sup> + 10<sup>15</sup> states) is much fewer states than searching 26 moves
deep to solve directly from the scramble (roughly 18<sup>26</sup> states). It also increases the effectiveness of 
pruning because you can prune each phase separately.


### Algorithm

The algorithm starts by recursively searching for DR states (phase 1) in 9 moves or fewer. Each time it finds a DR 
state it searches further in phase 2 for a solution up to a max depth (depth of both phases combined) of 'optimal' 
(which starts as 24 but later matches the length of the shortest solution found so far). Once phase 1 has finished 
searching at a depth of 9, it moves on to depth 10 and iterates up to 12.


### Coordinates

The 'cubie level' stores the states of the Rubik's Cube as arrays of pieces (or cubies) and their orientations. When
you want to make a move, you have to permute the pieces and orientations (and occasionally adjust the 
orientations again). For example a U move permutes the top four corners and top four edges. Making moves at the
'cubie level' requires a lot of calculations. Coordinates and tables are used to reduce the number of calculations.

In the first phase the coordinates are (CO, EO, EqL). In the second phase the coordinates are (CP, EP, EqP).
Each coordinate is an integer that refers to a specific state. For example: The CO coordinate refers to the orientation
of the 8 corners. At the 'cubie level' this would look something like (0, 2, 1, 2, 1, 0, 1, 2), where each value denotes
the orientation of a specific corner. This array is converted into a single integer unique to that state.

Note that it's difficult (requires lots of calculations) to convert coordinates back into their corresponding
'cubie level' array. This effects the way we generate the move tables.

There are also a few 'helper coordinates' in phase 1 which are used to help the transition between phases.

### Move Tables

Move tables are used to reduce the number of calculations used. They store the relationship between coordinates. 
E.g. coMoveTable\[450]\[12] = 208 means applying a B move (move 12) to the state 450 brings you to the 
state 208.

The move tables are generated by applying moves at the 'cubie level' and then converting them to coordinates.


### Distance Tables

Distance tables are used for pruning. They store the minimum number of moves needed to get to the solved state (of
that coordinate).

The distance tables are generated by giving the solved coordinate a value of 0 and then using the move table to find 
states that are 1 move away, then 2 moves away and so on.

